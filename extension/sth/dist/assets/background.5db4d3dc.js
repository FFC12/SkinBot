import{b as u,a as b}from"./browser-polyfill.9b4b3f77.js";let $=()=>({events:{},emit(e,...t){(this.events[e]||[]).forEach(n=>n(...t))},on(e,t){return(this.events[e]=this.events[e]||[]).push(t),()=>this.events[e]=(this.events[e]||[]).filter(n=>n!==t)}});const B=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],_=Symbol(".toJSON was called"),F=e=>{e[_]=!0;const t=e.toJSON();return delete e[_],t},j=({from:e,seen:t,to_:n,forceEnumerable:o,maxDepth:d,depth:i})=>{const r=n||(Array.isArray(e)?[]:{});if(t.push(e),i>=d)return r;if(typeof e.toJSON=="function"&&e[_]!==!0)return F(e);for(const[s,c]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(c)){r[s]="[object Buffer]";continue}if(c!==null&&typeof c=="object"&&typeof c.pipe=="function"){r[s]="[object Stream]";continue}if(typeof c!="function"){if(!c||typeof c!="object"){r[s]=c;continue}if(!t.includes(e[s])){i++,r[s]=j({from:e[s],seen:[...t],forceEnumerable:o,maxDepth:d,depth:i});continue}r[s]="[Circular]"}}for(const{property:s,enumerable:c}of B)typeof e[s]=="string"&&Object.defineProperty(r,s,{value:e[s],enumerable:o?!0:c,configurable:!0,writable:!0});return r};function W(e,t={}){const{maxDepth:n=Number.POSITIVE_INFINITY}=t;return typeof e=="object"&&e!==null?j({from:e,seen:[],forceEnumerable:!0,maxDepth:n,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}var E={exports:{}};const J=e=>typeof crypto!="undefined"&&typeof crypto.getRandomValues=="function"?()=>{const t=crypto.getRandomValues(new Uint8Array(1))[0];return(t>=e?t%e:t).toString(e)}:()=>Math.floor(Math.random()*e).toString(e),O=(e=7,t=!1)=>Array.from({length:e},J(t?16:36)).join("");E.exports=O;E.exports.default=O;var A=E.exports,V=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,P=e=>{const[,t,n,o]=e.match(V)||[];return{context:t,tabId:+n,frameId:o?+o:void 0}},y=e=>u[e],z=()=>{var e,t,n;const o=u.runtime.getManifest();if(typeof window=="undefined")return"background";const d=((e=o.browser_action)==null?void 0:e.default_popup)||((t=o.action)==null?void 0:t.default_popup);return d&&new URL(u.runtime.getURL(d)).pathname===window.location.pathname?"popup":(n=o.options_ui)!=null&&n.page&&new URL(u.runtime.getURL(o.options_ui.page)).pathname===window.location.pathname?"options":"background"},a=y("devtools")?"devtools":y("tabs")?z():y("extension")?"content-script":typeof document!="undefined"?"window":null,N=A(),v=new Map,R=new Map,I=new Set,x=new Map,l=null,h,U;g();function g(){if(a===null)throw new Error("Unable to detect runtime context i.e webext-bridge can't figure out what to do");if((a==="window"||a==="content-script")&&window.addEventListener("message",Q),a==="content-script"&&top===window&&(l=u.runtime.connect(),l.onMessage.addListener(e=>{f(e)}),l.onDisconnect.addListener(()=>{l=null,g()})),a==="content-script"&&top!==window&&(l=u.runtime.connect(),l.onMessage.addListener(e=>{f(e)}),l.onDisconnect.addListener(()=>{l=null,g()})),a==="devtools"){const{tabId:e}=u.devtools.inspectedWindow,t=`devtools@${e}`;l=u.runtime.connect(void 0,{name:t}),l.onMessage.addListener(n=>{f(n)}),l.onDisconnect.addListener(()=>{l=null,g()})}if(a==="popup"||a==="options"){const e=`${a}`;l=u.runtime.connect(void 0,{name:e}),l.onMessage.addListener(t=>{f(t)}),l.onDisconnect.addListener(()=>{l=null,g()})}a==="background"&&u.runtime.onConnect.addListener(e=>{let t=e.name||`content-script@${e.sender.tab.id}`;const n=e.sender.frameId;n&&(t=`${t}.${n}`);const{context:o,tabId:d,frameId:i}=P(t);!d&&o!=="popup"&&o!=="options"||(x.set(t,e),I.forEach(r=>{r.resolvedDestination===t&&(e.postMessage(r.message),I.delete(r))}),e.onDisconnect.addListener(()=>{x.delete(t)}),e.onMessage.addListener(r=>{var s;(s=r==null?void 0:r.origin)!=null&&s.context&&(r.origin.tabId=d,r.origin.frameId=i,f(r))}))})}function f(e){const{origin:t,destination:n}=e;if(!e.hops.includes(N)&&(e.hops.push(N),!(a==="content-script"&&[n,t].some(o=>(o==null?void 0:o.context)==="window")&&!U))){if(!n)return H(e);if(n.context){if(a==="window")return M(window,e);if(a==="content-script"&&n.context==="window")return e.destination=null,M(window,e);if(["devtools","content-script","popup","options"].includes(a))return n.context==="background"&&(e.destination=null),l.postMessage(e);if(a==="background"){const{context:o,tabId:d,frameId:i}=n,{tabId:r}=t;o!=="window"?e.destination=null:e.destination.tabId=null;let s=["popup","options"].includes(o)?o:`${o==="window"?"content-script":o}@${d||r}`;i&&(s=`${s}.${i}`);const c=x.get(s);c?c.postMessage(e):I.add({resolvedDestination:s,message:e})}}}}async function H(e){const{transactionId:t,messageID:n,messageType:o}=e,d=()=>{const r=v.get(t);if(r){const{err:s,data:c}=e;if(s){const p=s,L=self[p.name],C=new(typeof L=="function"?L:Error)(p.message);for(const D in p)C[D]=p[D];r.reject(C)}else r.resolve(c);v.delete(t)}},i=async()=>{let r,s,c=!1;try{const p=R.get(n);if(typeof p=="function")r=await p({sender:e.origin,id:n,data:e.data,timestamp:e.timestamp});else throw c=!0,new Error(`[webext-bridge] No handler registered in '${a}' to accept messages with id '${n}'`)}catch(p){s=p}finally{if(s&&(e.err=W(s)),f({...e,messageType:"reply",data:r,origin:{context:a,tabId:null},destination:e.origin,hops:[]}),s&&!c)throw r}};switch(o){case"reply":return d();case"message":return i()}}async function Q({data:e,ports:t}){if(!(a==="content-script"&&!U)){if(e.cmd==="__crx_bridge_verify_listening"&&e.scope===h&&e.context!==a)t[0].postMessage(!0);else if(e.cmd==="__crx_bridge_route_message"&&e.scope===h&&e.context!==a){const{payload:n}=e;a==="content-script"&&(n.origin={context:"window",tabId:null}),f(n)}}}function M(e,t){Y();const n=new MessageChannel,o=setTimeout(()=>{n.port1.onmessage=null,M(e,t)},300);n.port1.onmessage=()=>{clearTimeout(o),e.postMessage({cmd:"__crx_bridge_route_message",scope:h,context:a,payload:t},"*")},e.postMessage({cmd:"__crx_bridge_verify_listening",scope:h,context:a},"*",[n.port2])}function Y(){throw new Error(`webext-bridge uses window.postMessage to talk with other "window"(s), for message routing and stuff,which is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used\``)}function S(e,t){R.set(e,t)}async function k(e,t,n="background"){const o=typeof n=="string"?P(n):n,d="Bridge#sendMessage ->";if(!o.context)throw new TypeError(`${d} Destination must be any one of known destinations`);if(a==="background"){const{context:i,tabId:r}=o;if(i!=="background"&&!r)throw new TypeError(`${d} When sending messages from background page, use @tabId syntax to target specific tab`)}return new Promise((i,r)=>{const s={messageID:e,data:t,destination:o,messageType:"message",transactionId:A(),origin:{context:a,tabId:null},hops:[],timestamp:Date.now()};v.set(s.transactionId,{resolve:i,reject:r}),f(s)})}var m=class{constructor(e){this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},this.internalInfo=e,this.emitter=$(),this.isClosed=!1,m.initDone||(S("__crx_bridge_stream_transfer__",t=>{const{streamId:n,streamTransfer:o,action:d}=t.data,i=m.openStreams.get(n);i&&!i.isClosed&&(d==="transfer"&&i.emitter.emit("message",o),d==="close"&&(m.openStreams.delete(n),i.handleStreamClose()))}),m.initDone=!0),m.openStreams.set(e.streamId,this)}get info(){return this.internalInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");k("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:e,action:"transfer"},this.internalInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),k("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:null,action:"close"},this.internalInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,t){const n=this.emitter.on(e,t);return Object.assign(n,{dispose:n,close:n})}},T=m;T.initDone=!1;T.openStreams=new Map;var G=new Map,K=$();S("__crx_bridge_stream_open__",e=>new Promise(t=>{const{sender:n,data:o}=e,{channel:d}=o;let i=!1,r=()=>{};const s=()=>{const c=G.get(d);typeof c=="function"?(c(new T({...o,endpoint:n})),i&&r(),t(!0)):i||(i=!0,r=K.on("did-change-stream-callbacks",s))};s()}));b.exports.runtime.onInstalled.addListener(()=>{});let w=0;b.exports.tabs.onActivated.addListener(async({tabId:e})=>{if(!w){w=e;return}let t;try{t=await b.exports.tabs.get(w),w=e}catch{return}k("tab-prev",{title:t.title},{context:"content-script",tabId:e})});S("get-current-tab",async()=>{try{const e=await b.exports.tabs.get(w);return{title:e==null?void 0:e.title}}catch{return{title:void 0}}});
